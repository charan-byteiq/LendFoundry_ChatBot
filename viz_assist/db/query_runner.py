# query_runner.py
from langchain_core.tools import BaseTool
from pydantic import BaseModel, Field
from typing import Type, Optional, Any
import psycopg2
import pandas as pd
from dotenv import load_dotenv
import os
from datetime import datetime


load_dotenv()


class RedshiftQueryInput(BaseModel):
    """Input schema for Redshift SQL query tool."""
    sql_query: str = Field(description="The SQL query to execute on Redshift database")


class RedshiftSQLTool(BaseTool):
    """Custom tool for executing SQL queries on Redshift."""
    
    name: str = "redshift_sql_query"
    description: str = "Execute SQL queries on Redshift database and return results"
    args_schema: Type[BaseModel] = RedshiftQueryInput
    
    def _run(
        self,
        sql_query: str,
        run_manager: Optional[Any] = None,
    ) -> pd.DataFrame:
        """Execute the SQL query on Redshift and return DataFrame."""
        try:
            conn = self._get_connection()
            
            # Execute query and return DataFrame
            df = pd.read_sql_query(sql_query, conn)
            conn.close()
            return df  
         
        except Exception as e:
            return f"Error executing query: {str(e)}"
    
    async def _arun(
        self,
        sql_query: str,
        run_manager: Optional[Any] = None,
    ) -> str:
        """Async version - for now just call the sync version."""
        return self._run(sql_query, run_manager)
    
    def _get_connection(self):
        """Create a connection to Redshift"""
        try:
            conn = psycopg2.connect(
                host=os.getenv('REDSHIFT_HOST'),
                port=int(os.getenv('REDSHIFT_PORT', 5439)),
                dbname=os.getenv('REDSHIFT_DBNAME'),
                user=os.getenv('REDSHIFT_USER'),
                password=os.getenv('REDSHIFT_PASSWORD'),
                sslmode='require',
                connect_timeout=10
            )
            conn.autocommit = False
            return conn
        except Exception as e:
            raise Exception(f"Failed to connect to Redshift: {str(e)}")
    
    def run(self, query: str) -> str:
        """Convenience method for direct execution"""
        return self._run(query)
    
    def log_query(
        self, 
        user_question: str, 
        generated_sql: str, 
        thread_id: str = "default",
        execution_status: str = "success",
        row_count: int = 0
    ) -> bool:
        """
        Log user question and generated SQL to cdp.chatbot_logs table.
        
        Args:
            user_question: The original user question
            generated_sql: The SQL query generated by the LLM
            thread_id: Session/thread identifier
            execution_status: Status of query execution (success/failed/skipped)
            row_count: Number of rows returned by the query
        
        Returns:
            bool: True if logging successful, False otherwise
        """
        conn = None
        cursor = None
        
        try:
            # Get connection
            conn = self._get_connection()
            
            # Verify connection is valid
            if not conn or not hasattr(conn, 'cursor'):
                print(f" Invalid connection object: {type(conn)}")
                return False
            
            # Create cursor
            cursor = conn.cursor()
            
            # Truncate values to fit column constraints
            user_question_truncated = (user_question or "")[:5000]
            generated_sql_truncated = (generated_sql or "")[:65535]
            thread_id_truncated = (thread_id or "default")[:255]
            execution_status_truncated = (execution_status or "unknown")[:100]
            
            # SQL INSERT statement with parameterized query for safety
            insert_query = """
            INSERT INTO cdp.chatbot_logs 
            (user_question, generated_sql, thread_id, execution_status, row_count, logged_at)
            VALUES (%s, %s, %s, %s, %s, GETDATE())
            """
            
            # Execute the INSERT with parameters
            cursor.execute(insert_query, (
                user_question_truncated,
                generated_sql_truncated,
                thread_id_truncated,
                execution_status_truncated,
                row_count
            ))
            
            # Commit the transaction
            conn.commit()
            
            print(f" Logged query to cdp.chatbot_logs for thread: {thread_id}")
            return True
            
        except psycopg2.Error as db_error:
            print(f" Database error logging query: {db_error}")
            if hasattr(db_error, 'pgcode'):
                print(f"   Error Code: {db_error.pgcode}")
            if hasattr(db_error, 'pgerror'):
                print(f"   Error Message: {db_error.pgerror}")
            if conn:
                try:
                    conn.rollback()
                except:
                    pass
            return False
            
        except Exception as e:
            print(f" Failed to log query to database: {str(e)}")
            print(f"   Exception type: {type(e).__name__}")
            if conn:
                try:
                    conn.rollback()
                except:
                    pass
            return False
            
        finally:
            # Clean up resources
            try:
                if cursor:
                    cursor.close()
            except Exception as e:
                print(f" Error closing cursor: {e}")
            
            try:
                if conn:
                    conn.close()
            except Exception as e:
                print(f" Error closing connection: {e}")
